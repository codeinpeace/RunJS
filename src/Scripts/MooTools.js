/*
._ ._ 1.99dev
.____ ___ .__ .__ /\ \________ .__ /\ \ .___
/\ __` __`\ / __`\ / __`\ \ ,___ __`\ / __`\ \ \ /',__\
\ \ \/\ \/\ \\ \Z\ \\ \Z\ \ \ \_ \ \Z\ \\ \Z\ \ \ \_\__, `\
\ \_\ \_\ \_\\____/ \____/\ \__\ \____/ \____/\ \________/
\/_/\/_/\/_//___/ \/___/ \/__/\/___/ \/___/ \/_______/
the javascript framework
*/

/*
---
name: Core
description: The heart of MooTools.
provides: [MooTools, Type, typeOf, instanceOf, String.uniqueID, Object.each, Object.merge, Object.clone, Array.each, Array.clone, Date.new, Function.from, Array.from, Number.from, String.from]
...
*/

(function () {

    this.MooTools = {
        version: '1.99dev',
        build: '%build%'
    };

    var slice = Array.prototype.slice,
toString = Object.prototype.toString,
Function = this.Function,
enumerables = true;

    for (var i in { toString: 1 }) enumerables = null;
    if (enumerables) enumerables = ['hasOwnProperty', 'valueOf', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'constructor'];

    Function.prototype.overloadSetter = function (forceObjectArgument) {
        var self = this;
        return function (a, b) {
            if (a == null) return this;
            if (forceObjectArgument || typeof a != 'string') {
                for (var k in a) self.call(this, k, a[k]);
                if (enumerables) for (var i = enumerables.length; i--; ) {
                    k = enumerables[i];
                    if (a.hasOwnProperty(k)) self.call(this, k, a[k]);
                }
            } else {
                self.call(this, a, b);
            }
            return this;
        };
    };

    Function.prototype.overloadGetter = function (forceObjectResult) {
        // the forceObjectResult argument is used in those situations where a getter must always return a list of results.
        // Usually, when autogenerating a multiGetter with a plural name (such as getStuff autogenerated from getThing) we want the plural version of the getter to always behave the same way, regardless of the arguments passed.
        var self = this;
        return function (argument) {
            var args;
            if (typeof argument != 'string') args = argument; // the list of stuff to get is passed as an array
            else if (arguments.length > 1) args = arguments; // the list of stuff to get is passed as arguments
            else if (forceObjectResult) args = [argument]; //only one argument was passed, as we excluded the other 2 options before, but we wrap it in an array so that the object return is used.
            if (args) {
                var result = {};
                for (var i = 0; i < args.length; i++) result[args[i]] = self.call(this, args[i]);
                return result;
            } else {
                return self.call(this, a);
            }
        };
    };

    Function.prototype.extend = function (key, value) {
        this[key] = value;
    } .overloadSetter();

    Function.prototype.implement = function (key, value) {
        this.prototype[key] = value;
    } .overloadSetter();

    // typeOf, instanceOf

    var typeOf = this.typeOf = function (item) {
        if (item == null) return 'null';
        if (item.$family) return item.$family();

        if (item.nodeName) {
            if (item.nodeType == 1) return 'element';
            if (item.nodeType == 3) return (/\S/).test(item.nodeValue) ? 'textnode' : 'whitespace';
        } else if (typeof item.length == 'number') {
            if (item.callee) return 'arguments';
            if ('item' in item) return 'collection';
        }

        return typeof item;
    };

    this.instanceOf = function (item, object) {
        if (item == null) return false;
        var constructor = item.$constructor || item.constructor;
        while (constructor) {
            if (constructor === object) return true;
            constructor = constructor.parent;
        }
        return item instanceof object;
    };

    // From

    Function.from = function (item) {
        return (typeOf(item) == 'function') ? item : function () {
            return item;
        };
    };

    Array.from = function (item) {
        if (item == null) return [];
        return (Type.isEnumerable(item) && typeof item != 'string') ? (typeOf(item) == 'array') ? item : slice.call(item) : [item];
    };

    Number.from = function (item) {
        var number = parseFloat(item);
        return isFinite(number) ? number : null;
    };

    String.from = function (item) {
        return item + '';
    };

    // hide, protect

    Function.implement({

        hide: function () {
            this.$hidden = true;
            return this;
        },

        protect: function () {
            this.$protected = true;
            return this;
        }

    });

    // Type

    var Type = this.Type = function (name, object) {

        var lower = (name || '').toLowerCase();

        if (name) Type['is' + name] = function (item) {
            return (typeOf(item) == lower);
        };

        if (object == null) return null;

        if (name) object.prototype.$family = function () {
            return lower;
        } .hide();

        object.extend(this);
        object.$constructor = Type;
        object.prototype.$constructor = object.hide();

        return object;

    } .hide();

    Type.isEnumerable = function (item) {
        return (item != null && typeof item.length == 'number' && toString.call(item) != '[object Function]');
    };

    var extend = function (name, method) {
        if (method && method.$hidden) return;

        var previous = this[name];
        if (previous == null || !previous.$protected) this[name] = method;
    };

    var implement = function (name, method) {
        if (method && method.$hidden) return;

        var previous = this.prototype[name];
        if (previous == null || !previous.$protected) this.prototype[name] = method;

        if (this[name] == null && typeOf(method) == 'function') extend.call(this, name, function (item) {
            return method.apply(item, slice.call(arguments, 1));
        });
    };

    Type.implement({

        implement: implement.overloadSetter(),

        extend: extend.overloadSetter(),

        alias: function (key, value) {
            implement.call(this, key, this.prototype[value]);
        } .overloadSetter()

    });

    new Type('Type', Type);

    // Protect Types

    var protect = function (type, methods) {
        var object = this[type],
prototype = object.prototype,
isType = (object != Object);

        if (isType) new Type(type, object);

        for (var i = 0, l = methods.length; i < l; i++) {
            var name = methods[i],
generic = object[name],
proto = prototype[name];

            if (generic) generic.protect();

            if (isType && proto) {
                delete prototype[name];
                prototype[name] = proto.protect();
            }
        }

        if (isType) object.implement(prototype);

        return protect;
    };

    protect('String', [
'charAt', 'charCodeAt', 'concat', 'indexOf', 'lastIndexOf', 'match', 'quote', 'replace', 'search',
'slice', 'split', 'substr', 'substring', 'toLowerCase', 'toUpperCase'
])('Array', [
'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift', 'concat', 'join', 'slice',
'indexOf', 'lastIndexOf', 'filter', 'forEach', 'every', 'map', 'some', 'reduce', 'reduceRight'
])('Number', [
'toExponential', 'toFixed', 'toLocaleString', 'toPrecision'
])('Function', [
'apply', 'call', 'bind'
])('RegExp', [
'exec', 'test'
])('Object', [
'create', 'defineProperty', 'defineProperties', 'keys',
'getPrototypeOf', 'getOwnPropertyDescriptor', 'getOwnPropertyNames',
'preventExtensions', 'isExtensible', 'seal', 'isSealed', 'freeze', 'isFrozen'
])('Date', [
'now'
]);

    Object.extend = extend.overloadSetter();

    Date.extend('now', function () {
        return +(new Date);
    });

    new Type('Boolean', Boolean);

    // fixes typeOf(NaN) returning as "number"

    Number.prototype.$family = function () {
        return (isFinite(this)) ? 'number' : 'null';
    } .hide();

    // forEach, each

    Object.extend('forEach', function (object, fn, bind) {
        for (var key in object) {
            if (object.hasOwnProperty(key)) fn.call(bind, object[key], key, object);
        }
    }).extend('each', Object.forEach);

    Array.implement({

        forEach: function (fn, context) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this) fn.call(context, this[i], i, this);
            }
        },

        each: function (fn, context) {
            this.forEach(fn, context);
            return this;
        }

    });

    // Array & Object cloning

    var clone = function (item) {
        switch (typeOf(item)) {
            case 'array': return item.clone();
            case 'object': return Object.clone(item);
            default: return item;
        }
    };

    Array.implement('clone', function () {
        var i = this.length, cloned = new Array(i);
        while (i--) cloned[i] = clone(this[i]);
        return cloned;
    });

    Object.extend('clone', function (object) {
        var cloned = {};
        for (var key in object) cloned[key] = clone(object[key]);
        return cloned;
    });

    // Object merging

    var merge = function (source, key, current) {
        switch (typeOf(current)) {
            case 'object':
                if (typeOf(source[key]) == 'object') Object.merge(source[key], current);
                else source[key] = Object.clone(current);
                break;
            case 'array': source[key] = current.clone(); break;
            default: source[key] = current;
        }
        return source;
    };

    Object.extend('merge', function (source, k, v) {
        if (typeof k == 'string') return merge(source, k, v);
        for (var i = 1, l = arguments.length; i < l; i++) {
            var object = arguments[i];
            for (var key in object) merge(source, key, object[key]);
        }
        return source;
    });

    // Object-less types

    ['Object', 'WhiteSpace', 'TextNode', 'Collection', 'Arguments'].each(function (name) {
        new Type(name);
    });

    // UID generator

    var UID = 0;
    String.extend('uniqueID', function () {
        return (Date.now() + (UID++)).toString(36);
    });

})();

/*
---
name: Array
description: Array prototypes and generics.
requires: Type
provides: Array
...
*/

Array.implement({

    /* standard */

    filter: function (fn, bind) {
        var results = [];
        for (var i = 0, l = this.length; i < l; i++) {
            if ((i in this) && fn.call(bind, this[i], i, this)) results.push(this[i]);
        }
        return results;
    },

    indexOf: function (item, from) {
        for (var l = this.length, i = (from < 0) ? Math.max(0, l + from) : from || 0; i < l; i++) {
            if (this[i] === item) return i;
        }
        return -1;
    },

    map: function (fn, bind) {
        var results = [];
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this) results[i] = fn.call(bind, this[i], i, this);
        }
        return results;
    },

    every: function (fn, bind) {
        for (var i = 0, l = this.length; i < l; i++) {
            if ((i in this) && !fn.call(bind, this[i], i, this)) return false;
        }
        return true;
    },

    some: function (fn, bind) {
        for (var i = 0, l = this.length; i < l; i++) {
            if ((i in this) && fn.call(bind, this[i], i, this)) return true;
        }
        return false;
    },

    /* non standard */

    pair: function (fn, bind) {
        var object = {};
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this) object[this[i]] = fn.call(bind, this[i], i, this);
        }
        return object;
    },

    clean: function () {
        return this.filter(function (item) {
            return item != null;
        });
    },

    pick: function () {
        for (var i = 0, l = this.length; i < l; i++) {
            if (this[i] != null) return this[i];
        }
        return null;
    },

    invoke: function (name) {
        var args = Array.slice(arguments, 1), results = [];
        for (var i = 0, j = this.length; i < j; i++) {
            var item = this[i];
            results.push(item[name].apply(item, args));
        }
        return results;
    },

    append: function (array) {
        this.push.apply(this, array);
        return this;
    },

    contains: function (item, from) {
        return this.indexOf(item, from) != -1;
    },

    last: function () {
        var length = this.length;
        return (length) ? this[length - 1] : null;
    },

    random: function () {
        var length = this.length;
        return (length) ? this[Number.random(0, length - 1)] : null;
    },

    include: function (item) {
        if (!this.contains(item)) this.push(item);
        return this;
    },

    combine: function (array) {
        for (var i = 0, l = array.length; i < l; i++) this.include(array[i]);
        return this;
    },

    erase: function (item) {
        for (var i = this.length; i--; i) {
            if (this[i] === item) this.splice(i, 1);
        }
        return this;
    },

    empty: function () {
        this.length = 0;
        return this;
    },

    flatten: function () {
        var array = [];
        for (var i = 0, l = this.length; i < l; i++) {
            var ti = this[i], t = typeOf(this[i]);
            if (t == 'null') continue;
            array = array.concat((t == 'array' || t == 'collection' || t == 'arguments' || instanceOf(ti, Array)) ? Array.flatten(ti) : ti);
        }
        return array;
    },

    item: function (at) {
        var length = this.length;
        if (at < 0) at = (at % length) + length;
        return (at < 0 || at >= length || this[at] == null) ? null : this[at];
    }

});

/*
---
name: Function
description: Function prototypes and generics.
requires: Type
provides: Function
...
*/

Function.extend('attempt', function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
        try {
            return arguments[i]();
        } catch (e) { }
    }
    return null;
});

Function.implement({

    bind: function (bind) {
        var self = this,
args = (arguments.length > 1) ? Array.slice(arguments, 1) : null;

        return function () {
            if (!args && !arguments.length) return self.call(bind);
            if (args && arguments.length) return self.apply(bind, args.concat(Array.from(arguments)));
            return self.apply(bind, args || arguments);
        };
    },

    attempt: function (args, bind) {
        try {
            return this.apply(bind, args);
        } catch (e) { }

        return null;
    },

    pass: function (args, bind) {
        args = (args != null) ? Array.from(args) : [];
        args.unshift(bind);
        return this.bind.apply(this, args);
    },

    delay: function (delay, bind, args) {
        return setTimeout(this.pass((args == null ? [] : args), bind), delay);
    },

    periodical: function (periodical, bind, args) {
        return setInterval(this.pass((args == null ? [] : args), bind), periodical);
    }

});

/*
---
name: Number
description: Number prototypes and generics.
requires: Type
provides: Number
...
*/

Number.extend({

    random: function (min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }

});

Number.implement({

    limit: function (min, max) {
        return Math.min(max, Math.max(min, this));
    },

    round: function (precision) {
        precision = Math.pow(10, precision || 0);
        return Math.round(this * precision) / precision;
    },

    times: function (fn, bind) {
        for (var i = 0; i < this; i++) fn.call(bind, i, null, this);
    },

    toInt: function (base) {
        return parseInt(this, base || 10);
    },

    toFloat: function () {
        return parseFloat(this);
    }

});

['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'exp', 'floor', 'log', 'max', 'min', 'pow', 'sin', 'sqrt', 'tan'].each(function (name) {
    Number.extend(name, Math[name]).implement(name, function () {
        return Math[name].apply(null, [this].concat(Array.slice(arguments)));
    });
});

/*
---
name: Object
description: Object generics
requires: Type
provides: Object
...
*/

Object.extend({

    getLength: function (object) {
        var length = 0;
        for (var key in object) length++;
        return length;
    },

    from: function (keys, values) {
        var object = {};
        for (var i = 0; i < keys.length; i++) {
            var value = values[i];
            object[keys[i]] = (value != null) ? value : null;
        }
        return object;
    },

    append: function (original) {
        for (var i = 1, l = arguments.length; i < l; i++) {
            var extended = arguments[i] || {};
            for (var key in extended) original[key] = extended[key];
        }
        return original;
    },

    subset: function (object, keys) {
        var results = {};
        for (var i = 0, l = keys.length; i < l; i++) {
            var k = keys[i], value = object[k];
            results[k] = (value != null) ? value : null;
        }
        return results;
    },

    map: function (object, fn, bind) {
        var results = {};
        for (var key in object) results[key] = fn.call(bind, object[key], key, object);
        return results;
    },

    filter: function (object, fn, bind) {
        var results = {};
        for (var key in object) {
            if (fn.call(bind, object[key], key, object)) results[key] = object[key];
        }
        return results;
    },

    every: function (object, fn, bind) {
        for (var key in object) {
            if (!fn.call(bind, object[key], key)) return false;
        }
        return true;
    },

    some: function (object, fn, bind) {
        for (var key in object) {
            if (fn.call(bind, object[key], key)) return true;
        }
        return false;
    },

    keys: function (object) {
        var keys = [];
        for (var key in object) {
            if (object.hasOwnProperty(key)) keys.push(key);
        }
        return keys;
    },

    values: function (object) {
        var values = [];
        for (var key in object) {
            if (object.hasOwnProperty(key)) values.push(object[key]);
        }
        return values;
    },

    keyOf: function (object, value) {
        for (var key in object) {
            if (object.hasOwnProperty(key) && object[key] === value) return key;
        }
        return null;
    },

    contains: function (object, value) {
        return Object.keyOf(object, value) != null;
    }

});

/*
---
name: String
description: String prototypes and generics.
requires: Type
provides: String
...
*/

String.implement({

    test: function (regex, params) {
        return ((typeOf(regex) == 'string') ? new RegExp(regex, params) : regex).test(this);
    },

    contains: function (string, separator) {
        return ((separator) ? (separator + this + separator).indexOf(separator + string + separator) : this.indexOf(string)) > -1;
    },

    trim: function () {
        return this.replace(/^\s+|\s+$/g, '');
    },

    clean: function () {
        return this.replace(/\s+/g, ' ').trim();
    },

    camelCase: function () {
        return this.replace(/-\D/g, function (match) {
            return match.charAt(1).toUpperCase();
        });
    },

    hyphenate: function () {
        return this.replace(/[A-Z]/g, function (match) {
            return '-' + match.toLowerCase();
        });
    },

    capitalize: function () {
        return this.replace(/\b[a-z]/g, function (match) {
            return match.toUpperCase();
        });
    },

    escapeRegExp: function () {
        return this.replace(/([-.*+?^${}()|[\]\/\\])/g, '\\$1');
    },

    substitute: function (object, regexp) {
        return this.replace(regexp || (/\\?\{([^{}]+)\}/g), function (match, name) {
            if (match.charAt(0) == '\\') return match.slice(1);
            return (object[name] != null) ? object[name] : '';
        });
    },

    toInt: function (base) {
        return parseInt(this, base || 10);
    },

    toFloat: function () {
        return parseFloat(this);
    }

});

/*
---
name: Accessor
description: Accessor
requires: [typeOf, Array, Function, String, Object]
provides: Accessor
...
*/

(function () {

    this.Accessor = function (singular, plural) {

        var accessor = {}, matchers = [];

        singular = (singular || '').capitalize();
        if (!plural) plural = singular + 's';

        var define = 'define', lookup = 'lookup', match = 'match', each = 'each';

        var defineSingular = this[define + singular] = function (key, value) {
            if (typeOf(key) == 'regexp') matchers.push({ 'regexp': key, 'action': value });
            else accessor[key] = value;
            return this;
        };

        var definePlural = this[define + plural] = function (object) {
            for (var key in object) accessor[key] = object[key];
            return this;
        };

        var matchSingular = this[match + singular] = function (name) {
            for (var l = matchers.length; l--; l) {
                var matcher = matchers[l], match = name.match(matcher.regexp);
                if (match && (match = match.slice(1))) return function () {
                    return matcher.action.apply(this, Array.slice(arguments).append(match));
                };
            }
            return null;
        };

        var lookupSingular = this[lookup + singular] = function (key) {
            return (accessor.hasOwnProperty(key) && accessor[key]) || null;
        };

        var lookupPlural = this[lookup + plural] = lookupSingular.overloadGetter(true);

        var eachSingular = this[each + singular] = function (fn, bind) {
            Object.each(accessor, fn, bind);
        };

    };

})();

/*
---
name: JSON
description: JSON encoder and decoder
requires: [typeOf, Array, String]
provides: JSON
...
*/

if (!this.JSON) this.JSON = {};

(function () {

    var special = { '\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"': '\\"', '\\': '\\\\' };

    var escape = function (chr) {
        return special[chr] || '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    };

    JSON.validate = function (string) {
        string = string.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
replace(/(?:^|:|,)(?:\s*\[)+/g, '');

        return (/^[\],:{}\s]*$/).test(string);
    };

    JSON.encode = JSON.stringify || function (obj) {
        if (obj && obj.toJSON) obj = obj.toJSON();

        switch (typeOf(obj)) {
            case 'string':
                return '"' + obj.replace(/[\x00-\x1f\\"]/g, escape) + '"';
            case 'array':
                return '[' + obj.map(JSON.encode).clean() + ']';
            case 'object':
                var string = [];
                for (var key in obj) {
                    var json = JSON.encode(obj[key]);
                    if (json) string.push(JSON.encode(key) + ':' + json);
                }
                return '{' + string + '}';
            case 'number': case 'boolean': return '' + obj;
            case 'null': return 'null';
        }

        return null;
    };

    JSON.decode = function (string, secure) {
        if (!string || typeOf(string) != 'string') return null;

        if (secure || JSON.secure) {
            if (JSON.parse) return JSON.parse(string);
            if (!JSON.validate(string)) throw new Error('JSON could not decode the input; security is enabled and the value is not secure.');
        }

        return eval('(' + string + ')');
    };

})();

/*
---
name: Table
description: LUA-Style table implementation.
requires: [Core/Type, Core/Array]
provides: Table
...
*/

(function () {

    var Table = this.Table = function () {

        this.length = 0;
        var keys = [], values = [];

        this.set = function (key, value) {
            var index = keys.indexOf(key);
            if (index == -1) {
                var length = keys.length;
                keys[length] = key;
                values[length] = value;
                this.length++;
            } else {
                values[index] = value;
            }
            return this;
        };

        this.get = function (key) {
            var index = keys.indexOf(key);
            return (index == -1) ? null : values[index];
        };

        this.unset = function (key) {
            var index = keys.indexOf(key);
            if (index != -1) {
                this.length--;
                keys.splice(index, 1);
                return values.splice(index, 1)[0];
            }
            return null;
        };

        this.erase = function (value) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (values[i] === value) {
                    this.length--;
                    keys.splice(i, 1);
                    values.splice(i, 1);
                }
            }
            return this;
        };

        this.each = this.forEach = function (fn, context) {
            for (var i = 0, l = this.length; i < l; i++) fn.call(context, values[i], keys[i], this);
        };

    };

    if (this.Type) new Type('Table', Table);

})();


/*
---
name: Class
description: Contains the Class Function for easily creating, extending, and implementing reusable Classes.
requires: [Type, Array, String, Function, Number, Object, Accessor]
provides: Class
...
*/

(function () {

    var Class = this.Class = new Type('Class', function (params) {

        if (instanceOf(params, Function)) params = { 'initialize': params };

        var newClass = function () {
            reset(this);
            if (newClass.$prototyping) return this;
            this.$caller = null;
            var value = (this.initialize) ? this.initialize.apply(this, arguments) : this;
            this.$caller = this.caller = null;
            return value;
        } .extend(this).hide();

        newClass.implement(params);

        newClass.$constructor = Class;
        newClass.prototype.$constructor = newClass;
        newClass.prototype.parent = parent;

        return newClass;

    });

    var parent = function () {
        if (!this.$caller) throw new Error('The method "parent" cannot be called.');
        var name = this.$caller.$name, parent = this.$caller.$owner.parent;
        var previous = (parent) ? parent.prototype[name] : null;
        if (!previous) throw new Error('The method "' + name + '" has no parent.');
        return previous.apply(this, arguments);
    } .hide();

    var reset = function (object) {
        for (var key in object) {
            var value = object[key];
            switch (typeOf(value)) {
                case 'object':
                    var F = function () { };
                    F.prototype = value;
                    var instance = new F;
                    object[key] = reset(instance);
                    break;
                case 'array': object[key] = value.clone(); break;
            }
        }
        return object;
    };

    var wrap = function (self, key, method) {
        if (method.$origin) method = method.$origin;

        return function () {
            if (method.$protected && this.$caller == null) throw new Error('The method "' + key + '" cannot be called.');
            var caller = this.caller, current = this.$caller;
            this.caller = current; this.$caller = arguments.callee;
            var result = method.apply(this, arguments);
            this.$caller = current; this.caller = caller;
            return result;
        } .extend({ $owner: self, $origin: method, $name: key });
    };

    Class.extend(new Accessor('Mutator'));

    var implement = function (key, value, retainOwner) {

        var mutator = Class.matchMutator(key) || Class.lookupMutator(key);

        if (mutator) {
            value = mutator.call(this, value);
            if (value == null) return;
        }

        if (typeOf(value) == 'function') {
            if (value.$hidden) return;
            this.prototype[key] = (retainOwner) ? value : wrap(this, key, value);
        } else {
            Object.merge(this.prototype, key, value);
        }

    };

    var implementClass = function (item) {
        var instance = new item;
        for (var key in instance) implement.call(this, key, instance[key], true);
    };

    Class.implement('implement', function (a, b) {

        switch (typeOf(a)) {
            case 'string': implement.call(this, a, b); break;
            case 'class': implementClass.call(this, a); break;
            default: for (var p in a) implement.call(this, p, a[p]); break;
        }

        return this;

    }).defineMutators({

        Extends: function (parent) {
            this.parent = parent;
            parent.$prototyping = true;
            var proto = new parent;
            delete parent.$prototyping;
            this.prototype = proto;
        },

        Implements: function (items) {
            Array.from(items).each(function (item) {
                this.implement(item);
            }, this);
        }

    }).defineMutator(/^protected\s(\w+)$/, function (fn, name) {
        implement.call(this, name, fn.protect());
    }).defineMutator(/^linked\s(\w+)$/, function (value, name) {
        this.prototype[name] = value;
    });

})();

/*
---
name: Events
description: Events
requires: [Type, Array, Function, Class, Table]
provides: Events
...
*/

(function () {

    var uid = '$' + String.uniqueID();

    this.Events = new Class({

        listen: function (type, fn) {
            if (!this[uid]) this[uid] = {};

            if (!this[uid][type]) this[uid][type] = new Table;
            var events = this[uid][type];
            if (events.get(fn)) return this;

            var bound = fn.bind(this);

            events.set(fn, bound);

            return this;
        } .overloadSetter(),

        ignore: function (type, fn) {
            if (!this[uid]) return this;

            var events = this[uid][type];
            if (!events) return this;

            if (type == null) { //ignore all
                for (var ty in this[uid]) this.ignore(ty);
            } else if (fn == null) { // ignore every of type
                events.each(function (fn) {
                    this.ignore(type, fn);
                }, this);
            } else { // ignore one
                events.unset(fn);
            }

            return this;
        } .overloadSetter(),

        fire: function (type) {
            if (!this[uid]) return this;
            var events = this[uid][type];
            if (!events) return this;

            var args = Array.slice(arguments, 1);

            events.each(function (fn, bound) {
                fn.apply(this, args);
            }, this);

            return this;
        }

    });

})();

/*
---
name: Options
description: Options
requires: [Type, Class, Object]
provides: Options
...
*/

(function () {

    var classSetOption = function (key, value) {
        if (!this.options) this.options = {};
        if (this.listen && (/^on[A-Z]/).test(key) && typeOf(value) == 'function') this.listen(key.replace(/^on([A-Z])/, function (full, first) {
            return first.toLowerCase();
        }), value);
        else Object.merge(this.options, key, value);
        return this;
    };

    var classGetOption = function (key) {
        var options = this.options;
        if (!options) return null;
        var value = options[key];
        return (value != null) ? value : null;
    };

    this.Options = new Class({
        setOption: classSetOption,
        setOptions: classSetOption.overloadSetter(),
        getOption: classGetOption,
        getOptions: classGetOption.overloadGetter(true)
    });

})();

/*
---
name: Store
description: Store
requires: [Type, String.uniqueID, Class]
provides: Store
...
*/

(function () {

    var uid = '$' + String.uniqueID();

    var storageOf = function (object) {
        return object[uid] || (object[uid] = {});
    };

    this.Store = new Class({

        store: function (key, value) {
            storageOf(this)[key] = value;
        } .overloadSetter(),

        retrieve: function (key, defaultValue) {
            var storage = storageOf(this);
            var value = storage[key];
            if (defaultValue != null && value == null) storage[key] = Function.from(defaultValue).call(this);
            return storage[key];
        },

        dump: function (key) {
            var storage = storageOf(this);
            var value = storage[key];
            delete storage[key];
            return value;
        } .overloadGetter()

    });

})();

/*
---
name: Chain
description: Chain
requires: [Class, Array]
provides: Chain
...
*/

(function () {

    this.Chain = new Class({

        chain: function (fn) {
            if (!this.$chain) this.$chain = [];
            this.$chain.push(fn);
            return this;
        },

        callChain: function () {
            return (this.$chain && this.$chain.length) ? this.$chain.shift().apply(this, arguments) : null;
        },

        clearChain: function () {
            delete this.$chain;
            return this;
        }

    });

})();

